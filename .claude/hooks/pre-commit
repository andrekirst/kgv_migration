#!/bin/bash

# Git Flow Pre-Commit Hook
# This script runs before each commit to enforce Git Flow conventions

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CLAUDE_CONFIG_DIR=".claude"
GIT_FLOW_CONFIG="$CLAUDE_CONFIG_DIR/git-flow.yml"

echo -e "${BLUE}üîç Running Git Flow pre-commit validation...${NC}"

# Function to check if we're in a Git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Not in a Git repository${NC}"
        exit 1
    fi
}

# Function to load configuration
load_config() {
    if [ ! -f "$GIT_FLOW_CONFIG" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Git Flow config not found at $GIT_FLOW_CONFIG${NC}"
        echo -e "${YELLOW}   Using default configuration${NC}"
        return 0
    fi
    
    # Basic validation that config exists
    if [ -r "$GIT_FLOW_CONFIG" ]; then
        echo -e "${GREEN}‚úÖ Git Flow configuration loaded${NC}"
    else
        echo -e "${RED}‚ùå Cannot read Git Flow configuration${NC}"
        exit 1
    fi
}

# Function to get current branch name
get_current_branch() {
    git branch --show-current
}

# Function to check if branch name follows conventions
validate_branch_name() {
    local branch_name="$1"
    
    # Skip validation for main and develop branches
    if [[ "$branch_name" == "main" ]] || [[ "$branch_name" == "develop" ]]; then
        return 0
    fi
    
    # Define patterns
    local feature_pattern="^feature/ISSUE-[0-9]+-[a-z0-9-]+$"
    local bugfix_pattern="^bugfix/ISSUE-[0-9]+-[a-z0-9-]+$"
    local hotfix_pattern="^hotfix/v[0-9]+\.[0-9]+\.[0-9]+-[a-z0-9-]+$"
    local release_pattern="^release/v[0-9]+\.[0-9]+\.[0-9]+$"
    local docs_pattern="^docs/[a-z0-9-]+$"
    local infra_pattern="^infra/[a-z0-9-]+$"
    
    if [[ $branch_name =~ $feature_pattern ]] || \
       [[ $branch_name =~ $bugfix_pattern ]] || \
       [[ $branch_name =~ $hotfix_pattern ]] || \
       [[ $branch_name =~ $release_pattern ]] || \
       [[ $branch_name =~ $docs_pattern ]] || \
       [[ $branch_name =~ $infra_pattern ]]; then
        echo -e "${GREEN}‚úÖ Branch name follows convention: $branch_name${NC}"
        return 0
    else
        echo -e "${RED}‚ùå Branch name does not follow Git Flow conventions: $branch_name${NC}"
        echo -e "${YELLOW}Valid patterns:${NC}"
        echo -e "  ${BLUE}feature/ISSUE-123-short-description${NC}"
        echo -e "  ${BLUE}bugfix/ISSUE-123-short-description${NC}"
        echo -e "  ${BLUE}hotfix/v1.2.3-short-description${NC}"
        echo -e "  ${BLUE}release/v1.2.3${NC}"
        echo -e "  ${BLUE}docs/short-description${NC}"
        echo -e "  ${BLUE}infra/short-description${NC}"
        return 1
    fi
}

# Function to extract issue number from branch name
extract_issue_number() {
    local branch_name="$1"
    echo "$branch_name" | grep -oP 'ISSUE-\K\d+' || echo ""
}

# Function to validate commit message format
validate_commit_message() {
    local commit_message="$1"
    
    # Check for conventional commit format
    local conventional_pattern="^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\(.+\))?: .{1,50}"
    
    if [[ $commit_message =~ $conventional_pattern ]]; then
        echo -e "${GREEN}‚úÖ Commit message follows conventional format${NC}"
        return 0
    else
        echo -e "${RED}‚ùå Commit message does not follow conventional format${NC}"
        echo -e "${YELLOW}Expected format:${NC}"
        echo -e "  ${BLUE}type(scope): description${NC}"
        echo -e "${YELLOW}Types:${NC} feat, fix, docs, style, refactor, test, chore, perf, ci, build"
        echo -e "${YELLOW}Example:${NC} ${BLUE}feat(auth): add user authentication with JWT${NC}"
        return 1
    fi
}

# Function to check for issue reference in commit message
check_issue_reference() {
    local commit_message="$1"
    local branch_name="$2"
    local issue_number
    
    issue_number=$(extract_issue_number "$branch_name")
    
    if [ -n "$issue_number" ]; then
        if [[ $commit_message =~ "#$issue_number" ]] || [[ $commit_message =~ "Closes #$issue_number" ]]; then
            echo -e "${GREEN}‚úÖ Commit message references issue #$issue_number${NC}"
            return 0
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Commit message should reference issue #$issue_number${NC}"
            echo -e "${YELLOW}   Consider adding 'Closes #$issue_number' to your commit message${NC}"
            # Don't fail for this, just warn
            return 0
        fi
    fi
    
    return 0
}

# Function to check for secrets in staged files
check_for_secrets() {
    echo -e "${BLUE}üîç Scanning for potential secrets...${NC}"
    
    # List of patterns to check for
    local secret_patterns=(
        "password\s*=\s*['\"][^'\"]*['\"]"
        "secret\s*=\s*['\"][^'\"]*['\"]"
        "token\s*=\s*['\"][^'\"]*['\"]"
        "api_key\s*=\s*['\"][^'\"]*['\"]"
        "private_key"
        "BEGIN RSA PRIVATE KEY"
        "BEGIN PRIVATE KEY"
        "ghp_[a-zA-Z0-9]{36}"  # GitHub Personal Access Token
    )
    
    local found_secrets=false
    
    # Check staged files
    for file in $(git diff --cached --name-only); do
        if [ -f "$file" ]; then
            for pattern in "${secret_patterns[@]}"; do
                if grep -iE "$pattern" "$file" > /dev/null; then
                    echo -e "${RED}‚ùå Potential secret found in $file${NC}"
                    echo -e "${YELLOW}   Pattern: $pattern${NC}"
                    found_secrets=true
                fi
            done
        fi
    done
    
    if [ "$found_secrets" = true ]; then
        echo -e "${YELLOW}üîê Secrets detected! Please remove them before committing.${NC}"
        echo -e "${YELLOW}   Use environment variables or configuration files instead.${NC}"
        return 1
    else
        echo -e "${GREEN}‚úÖ No secrets detected${NC}"
        return 0
    fi
}

# Function to run linting on staged files
run_linting() {
    echo -e "${BLUE}üßπ Running linting on staged files...${NC}"
    
    # Check if we have staged .cs files
    local cs_files
    cs_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.cs$' || true)
    
    if [ -n "$cs_files" ]; then
        echo -e "${BLUE}   Checking C# files...${NC}"
        if command -v dotnet > /dev/null 2>&1; then
            if dotnet format --verify-no-changes --include $cs_files > /dev/null 2>&1; then
                echo -e "${GREEN}   ‚úÖ C# files pass formatting check${NC}"
            else
                echo -e "${RED}   ‚ùå C# files need formatting${NC}"
                echo -e "${YELLOW}   Run: dotnet format${NC}"
                return 1
            fi
        else
            echo -e "${YELLOW}   ‚ö†Ô∏è  dotnet CLI not found, skipping C# linting${NC}"
        fi
    fi
    
    # Check if we have staged .js/.ts/.tsx files
    local js_files
    js_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(js|ts|tsx)$' || true)
    
    if [ -n "$js_files" ]; then
        echo -e "${BLUE}   Checking JavaScript/TypeScript files...${NC}"
        if [ -d "frontend" ] && [ -f "frontend/package.json" ]; then
            cd frontend
            if command -v npm > /dev/null 2>&1; then
                if npm run lint:check > /dev/null 2>&1; then
                    echo -e "${GREEN}   ‚úÖ JS/TS files pass linting check${NC}"
                else
                    echo -e "${RED}   ‚ùå JS/TS files have linting errors${NC}"
                    echo -e "${YELLOW}   Run: npm run lint${NC}"
                    cd ..
                    return 1
                fi
            else
                echo -e "${YELLOW}   ‚ö†Ô∏è  npm not found, skipping JS/TS linting${NC}"
            fi
            cd ..
        fi
    fi
    
    return 0
}

# Function to check if direct push to protected branches
check_protected_branches() {
    local branch_name="$1"
    
    if [[ "$branch_name" == "main" ]] || [[ "$branch_name" == "develop" ]]; then
        echo -e "${RED}‚ùå Direct commits to $branch_name are not allowed${NC}"
        echo -e "${YELLOW}   Please create a feature branch and submit a Pull Request${NC}"
        return 1
    fi
    
    return 0
}

# Function to check for large files
check_file_sizes() {
    echo -e "${BLUE}üìè Checking file sizes...${NC}"
    
    local max_size_mb=10
    local max_size_bytes=$((max_size_mb * 1024 * 1024))
    local large_files_found=false
    
    # Check staged files
    for file in $(git diff --cached --name-only); do
        if [ -f "$file" ]; then
            local file_size
            file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
            
            if [ "$file_size" -gt "$max_size_bytes" ]; then
                local file_size_mb=$((file_size / 1024 / 1024))
                echo -e "${RED}‚ùå Large file detected: $file (${file_size_mb}MB)${NC}"
                large_files_found=true
            fi
        fi
    done
    
    if [ "$large_files_found" = true ]; then
        echo -e "${YELLOW}üìÅ Files larger than ${max_size_mb}MB detected!${NC}"
        echo -e "${YELLOW}   Consider using Git LFS for large files${NC}"
        return 1
    else
        echo -e "${GREEN}‚úÖ All files are within size limits${NC}"
        return 0
    fi
}

# Main execution
main() {
    check_git_repo
    load_config
    
    local current_branch
    current_branch=$(get_current_branch)
    
    echo -e "${BLUE}Current branch: $current_branch${NC}"
    
    # Validate branch name
    if ! validate_branch_name "$current_branch"; then
        exit 1
    fi
    
    # Check if trying to commit directly to protected branches
    if ! check_protected_branches "$current_branch"; then
        exit 1
    fi
    
    # Get commit message (from git commit -m or editor)
    local commit_message
    if [ -n "$1" ]; then
        commit_message="$1"
    else
        # Try to get commit message from git
        commit_message=$(git log --format=%B -n 1 HEAD 2>/dev/null || echo "")
    fi
    
    # If we have a commit message, validate it
    if [ -n "$commit_message" ]; then
        if ! validate_commit_message "$commit_message"; then
            echo -e "${YELLOW}üí° To fix your commit message, use:${NC}"
            echo -e "   ${BLUE}git commit --amend -m \"type(scope): your description\"${NC}"
            exit 1
        fi
        
        check_issue_reference "$commit_message" "$current_branch"
    fi
    
    # Security checks
    if ! check_for_secrets; then
        exit 1
    fi
    
    # File size checks
    if ! check_file_sizes; then
        echo -e "${YELLOW}‚ö†Ô∏è  Continuing with large files (consider optimizing)${NC}"
    fi
    
    # Linting checks
    if ! run_linting; then
        exit 1
    fi
    
    echo -e "${GREEN}üéâ All pre-commit checks passed!${NC}"
    exit 0
}

# Run main function with all arguments
main "$@"